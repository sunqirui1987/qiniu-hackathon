# OneStory 架构设计文档

## 概述

本文档定义OneStory平台的前端架构设计，包括路由结构、状态管理、数据流和视图间通信机制。

---

## 1. 路由架构

### 1.1 路由结构

```
/                                    - 首页/登录页
/dashboard                           - 项目列表页
/dashboard/:projectId                - 项目工作台(默认重定向到scriptView)
/dashboard/:projectId/scriptView     - 剧本编辑视图
/dashboard/:projectId/roleView       - 角色管理视图
/dashboard/:projectId/tableView      - 分镜表编辑视图
/dashboard/:projectId/videoView      - 视频编辑视图
/templates                           - 模板库
/templates/:templateId               - 模板详情
/profile                             - 个人中心
/settings                            - 设置页面
```

### 1.2 路由参数

**项目ID** (projectId):
```typescript
type ProjectId = string;  // UUID格式: "e8d297baeb01e1a0f0318c4daaaf584f"
```

**视图类型** (viewType):
```typescript
type ViewType = 'scriptView' | 'roleView' | 'tableView' | 'videoView';
```

### 1.3 路由守卫

**认证守卫**:
```typescript
const authGuard = (to, from, next) => {
  const token = localStorage.getItem('auth_token');
  if (!token && to.path !== '/') {
    next('/');
  } else {
    next();
  }
};
```

**项目权限守卫**:
```typescript
const projectGuard = async (to, from, next) => {
  const projectId = to.params.projectId;
  const hasPermission = await checkProjectPermission(projectId);
  
  if (!hasPermission) {
    next('/dashboard');
  } else {
    next();
  }
};
```

### 1.4 路由跳转逻辑

**默认视图重定向**:
```typescript
// 访问 /dashboard/:projectId 时
// 自动重定向到 /dashboard/:projectId/scriptView
router.beforeEach((to, from, next) => {
  if (to.path.match(/^\/dashboard\/[^/]+$/) && !to.path.endsWith('/')) {
    next(`${to.path}/scriptView`);
  } else {
    next();
  }
});
```

**Tab切换**:
```typescript
const switchTab = (viewType: ViewType) => {
  const projectId = route.params.projectId;
  router.push(`/dashboard/${projectId}/${viewType}`);
};
```

---

## 2. 状态管理架构

### 2.1 状态管理方案

采用 **Pinia** (Vue 3) 或 **Redux Toolkit** (React) 进行全局状态管理。

### 2.2 Store 结构

```typescript
// 全局状态树
interface RootState {
  user: UserState;           // 用户状态
  project: ProjectState;     // 项目状态
  script: ScriptState;       // 剧本状态
  role: RoleState;           // 角色状态
  storyboard: StoryboardState; // 分镜状态
  video: VideoState;         // 视频状态
  ui: UIState;               // UI状态
}
```

### 2.3 UserStore (用户状态)

```typescript
interface UserState {
  userId: string;
  username: string;
  avatar: string;
  email: string;
  planType: 'free' | 'premium' | 'pro';
  credits: number;
  isAuthenticated: boolean;
}

// Actions
const userStore = {
  state: () => ({...}),
  
  actions: {
    async login(credentials) { },
    async logout() { },
    async fetchUserInfo() { },
    async updateProfile(data) { }
  }
};
```

### 2.4 ProjectStore (项目状态)

```typescript
interface ProjectState {
  currentProject: Project | null;
  projectList: Project[];
  loading: boolean;
  error: string | null;
}

interface Project {
  id: string;
  name: string;
  coverUrl: string;
  content: string;
  style: string;
  createdAt: string;
  updatedAt: string;
}

// Actions
const projectStore = {
  state: () => ({...}),
  
  actions: {
    async fetchProjectList(params) { },
    async createProject(data) { },
    async loadProject(projectId) { },
    async updateProject(id, data) { },
    async deleteProject(id) { },
    async saveProject() { }
  },
  
  getters: {
    currentProjectId: (state) => state.currentProject?.id,
    hasUnsavedChanges: (state) => state.currentProject?.isDirty
  }
};
```

### 2.5 ScriptStore (剧本状态)

```typescript
interface ScriptState {
  content: string;
  isDirty: boolean;
  lastSaved: Date | null;
  aiSuggestions: string[];
}

// Actions
const scriptStore = {
  state: () => ({...}),
  
  actions: {
    updateContent(content: string) {
      this.content = content;
      this.isDirty = true;
      this.triggerAutoSave();
    },
    
    async save() {
      await projectStore.updateProject(projectId, {
        content: this.content
      });
      this.isDirty = false;
      this.lastSaved = new Date();
    },
    
    triggerAutoSave() {
      // 防抖保存，3秒无操作后自动保存
      debounce(() => this.save(), 3000);
    }
  }
};
```

### 2.6 RoleStore (角色状态)

```typescript
interface RoleState {
  roles: Role[];
  selectedRoleId: string | null;
  loading: boolean;
}

interface Role {
  id: string;
  name: string;
  description: string;
  imageUrl: string;
  origin: number;
}

// Actions
const roleStore = {
  state: () => ({...}),
  
  actions: {
    async fetchRoles(projectId, params) { },
    async addRole(projectId, roleData) { },
    async regenerateRole(roleId, params) { },
    async deleteRole(roleId) { }
  }
};
```

### 2.7 StoryboardStore (分镜状态)

```typescript
interface StoryboardState {
  shots: Shot[];
  selectedShotIds: string[];
  headers: Header[];
}

interface Shot {
  id: string;
  order: number;
  mainRole: {
    name: string;
    avatar: string;
  };
  description: string;
  duration: number;
  imageUrl: string;
  status: 'completed' | 'pending' | 'generating' | 'failed';
}

// Actions
const storyboardStore = {
  state: () => ({...}),
  
  actions: {
    async fetchShots(projectId) { },
    async updateShot(shotId, data) { },
    async deleteShot(shotId) { },
    async reorderShots(newOrder) { },
    async batchGenerateImages(projectId) { }
  }
};
```

### 2.8 VideoStore (视频状态)

```typescript
interface VideoState {
  videos: Video[];
  currentVideoId: string | null;
  timeline: TimelineState;
}

interface Video {
  id: string;
  shotId: string;
  videoUrl: string;
  status: 'completed' | 'processing' | 'failed';
  duration: number;
}

interface TimelineState {
  tracks: {
    video: VideoTrack[];
    audio: AudioTrack[];
    subtitle: SubtitleTrack[];
  };
  currentTime: number;
  totalDuration: number;
}

// Actions
const videoStore = {
  state: () => ({...}),
  
  actions: {
    async fetchVideos(projectId, storyboardId) { },
    async generateVideo(params) { },
    async updateTimeline(timeline) { }
  }
};
```

### 2.9 UIStore (UI状态)

```typescript
interface UIState {
  sidebarCollapsed: boolean;
  activeTab: ViewType;
  modals: {
    [key: string]: boolean;
  };
  notifications: Notification[];
}

// Actions
const uiStore = {
  state: () => ({...}),
  
  actions: {
    toggleSidebar() { },
    setActiveTab(tab: ViewType) { },
    showModal(modalId: string) { },
    hideModal(modalId: string) { },
    addNotification(notification: Notification) { },
    removeNotification(id: string) { }
  }
};
```

---

## 3. 视图间通信

### 3.1 EventBus 事件总线

使用事件总线实现松耦合的视图间通信。

```typescript
// EventBus 定义
import mitt from 'mitt';

type Events = {
  'script:updated': { content: string };
  'role:created': { roleId: string };
  'shot:generated': { shotId: string; imageUrl: string };
  'video:completed': { videoId: string };
};

export const eventBus = mitt<Events>();

// 发布事件
eventBus.emit('script:updated', { content: newContent });

// 订阅事件
eventBus.on('script:updated', (event) => {
  console.log('Script updated:', event.content);
});
```

### 3.2 视图通信流程

#### ScriptView → RoleView
```
用户在ScriptView编辑剧本
  ↓
scriptStore.updateContent()
  ↓
eventBus.emit('script:updated')
  ↓
roleStore监听事件 → 分析新角色
  ↓
RoleView自动刷新角色列表
```

#### RoleView → TableView
```
用户在RoleView创建/修改角色
  ↓
roleStore.addRole()
  ↓
eventBus.emit('role:created')
  ↓
storyboardStore监听事件 → 更新角色选项
  ↓
TableView角色下拉框自动更新
```

#### TableView → VideoView
```
用户在TableView生成分镜图片
  ↓
storyboardStore.batchGenerateImages()
  ↓
轮询检查生成状态
  ↓
eventBus.emit('shot:generated')
  ↓
videoStore监听事件 → 可开始生成视频
  ↓
VideoView显示"可生成视频"提示
```

### 3.3 数据流向图

```
┌─────────────┐
│   用户操作   │
└──────┬──────┘
       │
       ▼
┌─────────────┐      ┌──────────────┐
│  View组件   │◄─────│  EventBus    │
└──────┬──────┘      └──────▲───────┘
       │                    │
       ▼                    │
┌─────────────┐             │
│   Store     │             │
│  (Actions)  │             │
└──────┬──────┘             │
       │                    │
       ▼                    │
┌─────────────┐             │
│  API请求    │             │
└──────┬──────┘             │
       │                    │
       ▼                    │
┌─────────────┐             │
│  后端API    │             │
└──────┬──────┘             │
       │                    │
       ▼                    │
┌─────────────┐             │
│ Store更新    │─────────────┘
│ (Mutations)  │   emit event
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  View更新   │
└─────────────┘
```

---

## 4. 自动保存策略

### 4.1 保存时机

**触发条件**:
1. 内容修改后3秒无操作（防抖）
2. 切换Tab视图时
3. 离开页面前（beforeunload）
4. 定时保存（每30秒，如有修改）
5. 手动保存（Ctrl+S）

### 4.2 保存实现

```typescript
class AutoSaveManager {
  private saveTimeout: number | null = null;
  private lastSaveTime: Date | null = null;
  private saveInterval: number = 30000; // 30秒
  
  // 防抖保存
  debounceSave(callback: () => Promise<void>, delay: number = 3000) {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
    }
    
    this.saveTimeout = setTimeout(async () => {
      await callback();
      this.lastSaveTime = new Date();
    }, delay);
  }
  
  // 定时保存
  startPeriodicSave(callback: () => Promise<void>) {
    setInterval(async () => {
      const isDirty = projectStore.currentProject?.isDirty;
      if (isDirty) {
        await callback();
      }
    }, this.saveInterval);
  }
  
  // 离开前保存
  setupBeforeUnload() {
    window.addEventListener('beforeunload', async (e) => {
      const isDirty = projectStore.currentProject?.isDirty;
      if (isDirty) {
        e.preventDefault();
        e.returnValue = '';
        await projectStore.saveProject();
      }
    });
  }
}

// 使用
const autoSave = new AutoSaveManager();
autoSave.startPeriodicSave(() => projectStore.saveProject());
autoSave.setupBeforeUnload();
```

### 4.3 冲突处理

**版本控制**:
```typescript
interface SaveRequest {
  projectId: string;
  content: any;
  version: number;  // 乐观锁版本号
  timestamp: string;
}

// 保存时检查版本
async function saveWithConflictCheck(data: SaveRequest) {
  try {
    await api.updateProject(data);
  } catch (error) {
    if (error.code === 'VERSION_CONFLICT') {
      // 显示冲突解决弹窗
      showConflictResolver({
        local: data.content,
        remote: error.remoteContent,
        onResolve: (resolved) => {
          // 使用解决后的内容重新保存
          saveWithConflictCheck({
            ...data,
            content: resolved,
            version: error.remoteVersion
          });
        }
      });
    }
  }
}
```

---

## 5. 实时协作支持（可选）

### 5.1 WebSocket连接

```typescript
class CollaborationService {
  private ws: WebSocket;
  
  connect(projectId: string) {
    this.ws = new WebSocket(`wss://api.onestory.art/collaborate/${projectId}`);
    
    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      this.handleMessage(data);
    };
  }
  
  handleMessage(data: any) {
    switch (data.type) {
      case 'user:joined':
        // 显示用户加入提示
        break;
      case 'content:updated':
        // 远程内容更新
        this.mergeRemoteChanges(data.changes);
        break;
      case 'cursor:moved':
        // 显示其他用户光标位置
        break;
    }
  }
  
  sendUpdate(changes: any) {
    this.ws.send(JSON.stringify({
      type: 'content:update',
      changes
    }));
  }
}
```

### 5.2 OT (Operational Transformation)

使用 OT 算法处理并发编辑冲突。

```typescript
// 使用 ShareDB 或自定义OT实现
import ShareDB from 'sharedb/lib/client';

const connection = new ShareDB.Connection(ws);
const doc = connection.get('projects', projectId);

doc.subscribe((err) => {
  if (err) throw err;
  
  // 监听远程变更
  doc.on('op', (op, source) => {
    if (!source) {
      // 应用远程操作
      applyOp(op);
    }
  });
});

// 本地修改
function localEdit(changes) {
  const op = generateOp(changes);
  doc.submitOp(op, { source: true });
}
```

---

## 6. 离线编辑

### 6.1 离线存储

```typescript
import localforage from 'localforage';

class OfflineStorage {
  private db = localforage.createInstance({
    name: 'onestory-offline'
  });
  
  async saveProject(project: Project) {
    await this.db.setItem(`project:${project.id}`, {
      ...project,
      offlineModifiedAt: new Date().toISOString()
    });
  }
  
  async getProject(projectId: string): Promise<Project | null> {
    return await this.db.getItem(`project:${projectId}`);
  }
  
  async syncPendingChanges() {
    const keys = await this.db.keys();
    const pendingProjects = keys.filter(k => k.startsWith('project:'));
    
    for (const key of pendingProjects) {
      const project = await this.db.getItem(key);
      try {
        await api.updateProject(project);
        await this.db.removeItem(key);
      } catch (error) {
        console.error('Sync failed:', error);
      }
    }
  }
}
```

### 6.2 在线/离线检测

```typescript
class NetworkMonitor {
  private isOnline = navigator.onLine;
  
  constructor() {
    window.addEventListener('online', () => {
      this.isOnline = true;
      this.onOnline();
    });
    
    window.addEventListener('offline', () => {
      this.isOnline = false;
      this.onOffline();
    });
  }
  
  onOnline() {
    // 显示在线提示
    uiStore.addNotification({
      type: 'success',
      message: '已恢复网络连接，正在同步数据...'
    });
    
    // 同步离线修改
    offlineStorage.syncPendingChanges();
  }
  
  onOffline() {
    // 显示离线提示
    uiStore.addNotification({
      type: 'warning',
      message: '网络已断开，您的修改将在恢复连接后自动同步'
    });
  }
}
```

---

## 7. 性能优化策略

### 7.1 代码分割

```typescript
// 路由级代码分割
const routes = [
  {
    path: '/dashboard',
    component: () => import('./views/Dashboard.vue')
  },
  {
    path: '/dashboard/:projectId/scriptView',
    component: () => import('./views/ScriptView.vue')
  },
  {
    path: '/dashboard/:projectId/roleView',
    component: () => import('./views/RoleView.vue')
  },
  // ...
];
```

### 7.2 数据预取

```typescript
// 预取下一个可能访问的视图数据
router.beforeEach(async (to, from, next) => {
  if (to.params.projectId) {
    // 预取项目数据
    projectStore.loadProject(to.params.projectId);
    
    // 根据当前视图预取相关数据
    if (to.path.includes('roleView')) {
      roleStore.fetchRoles(to.params.projectId);
    } else if (to.path.includes('tableView')) {
      storyboardStore.fetchShots(to.params.projectId);
    }
  }
  next();
});
```

### 7.3 虚拟滚动

```typescript
// 对于长列表使用虚拟滚动
import { useVirtualList } from '@vueuse/core';

const { list, containerProps, wrapperProps } = useVirtualList(
  largeList,
  { itemHeight: 80 }
);
```

---

## 8. 错误处理

### 8.1 全局错误处理

```typescript
class ErrorHandler {
  handle(error: Error, context?: string) {
    console.error(`[${context}]`, error);
    
    // 根据错误类型显示不同提示
    if (error.message.includes('Network')) {
      uiStore.addNotification({
        type: 'error',
        message: '网络连接失败，请检查网络设置'
      });
    } else if (error.message.includes('Unauthorized')) {
      // 跳转到登录页
      router.push('/');
    } else {
      uiStore.addNotification({
        type: 'error',
        message: '操作失败，请重试'
      });
    }
    
    // 发送错误日志到服务器
    this.reportError(error, context);
  }
  
  reportError(error: Error, context?: string) {
    // 发送到日志服务
    api.logError({
      message: error.message,
      stack: error.stack,
      context,
      timestamp: new Date().toISOString()
    });
  }
}

export const errorHandler = new ErrorHandler();
```

### 8.2 API请求错误处理

```typescript
// Axios拦截器
axios.interceptors.response.use(
  response => response,
  error => {
    if (error.response) {
      switch (error.response.status) {
        case 401:
          // 未授权，清除token并跳转登录
          userStore.logout();
          break;
        case 403:
          errorHandler.handle(new Error('权限不足'));
          break;
        case 404:
          errorHandler.handle(new Error('资源不存在'));
          break;
        case 500:
          errorHandler.handle(new Error('服务器错误'));
          break;
      }
    }
    return Promise.reject(error);
  }
);
```

---

## 9. 监控与日志

### 9.1 性能监控

```typescript
// 页面加载性能
window.addEventListener('load', () => {
  const perfData = performance.getEntriesByType('navigation')[0];
  
  Amplitude.track('page_performance', {
    loadTime: perfData.loadEventEnd - perfData.fetchStart,
    domContentLoaded: perfData.domContentLoadedEventEnd - perfData.fetchStart,
    firstPaint: performance.getEntriesByType('paint')[0]?.startTime
  });
});

// API请求性能
axios.interceptors.request.use(config => {
  config.metadata = { startTime: new Date() };
  return config;
});

axios.interceptors.response.use(response => {
  const duration = new Date() - response.config.metadata.startTime;
  
  Amplitude.track('api_request', {
    endpoint: response.config.url,
    method: response.config.method,
    duration,
    status: response.status
  });
  
  return response;
});
```

### 9.2 用户行为追踪

```typescript
// 自动追踪关键操作
const trackableActions = [
  'project:created',
  'script:updated',
  'role:generated',
  'shot:generated',
  'video:exported'
];

trackableActions.forEach(action => {
  eventBus.on(action, (data) => {
    Amplitude.track(action, data);
  });
});
```

---

## 相关文档
- [API接口设计](./API接口设计.md)
- [设计系统](./设计系统.md)
- [Dashboard页面](./page/02-Dashboard.md)
